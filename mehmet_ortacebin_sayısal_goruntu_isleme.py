# -*- coding: utf-8 -*-
"""Mehmet_Ortacebin_Sayısal_Goruntu_Isleme

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rg12fbxjAttk2lNxjlY-X-MFTqyMCrGA

# MIDTERM

## VERI YUKLEME

Bu dersin arasınavında , [ChestX-ray8 dataset](https://arxiv.org/abs/1705.02315) veri seti'nden alınan göğüs röntgeni görüntüleriyle çalışacaksınız.
<img src="https://raw.githubusercontent.com/hardik0/AI-for-Medicine-Specialization/master/AI-for-Medical-Diagnosis/Week-1/xray-image.png" alt="U-net Image" width="300" align="middle"/>
"""

# Commented out IPython magic to ensure Python compatibility.
# Import necessary packages
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import os
import seaborn as sns
sns.set()

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/hardik0/AI-for-Medicine-Specialization
# %cd AI-for-Medicine-Specialization/AI-for-Medical-Diagnosis/

# Commented out IPython magic to ensure Python compatibility.
# %ls nih/

# Read csv file containing training datadata
train_df = pd.read_csv("nih/train-small.csv")
# Print first 5 rows
print(f'There are {train_df.shape[0]} rows and {train_df.shape[1]} columns in this data frame')
train_df.head()

"""Have a look at the various columns in this csv file. The file contains the names of chest x-ray images ("Image" column) and the columns filled with ones and zeros identify which diagnoses were given based on each x-ray image.

### Data types and null values check
Run the next cell to explore the data types present in each column and whether any null values exist in the data.
"""

# Look at the data type of each column and whether null values are present
train_df.info()

"""### Unique IDs check
"PatientId" has an identification number for each patient. One thing you'd like to know about a medical dataset like this is if you're looking at repeated data for certain patients or whether each image represents a different person.
"""

print(f"The total patient ids are {train_df['PatientId'].count()}, from those the unique ids are {train_df['PatientId'].value_counts().shape[0]} ")

"""As you can see, the number of unique patients in the dataset is less than the total number so there must be some overlap. For patients with multiple records, you'll want to make sure they do not show up in both training and test sets in order to avoid data leakage (covered later in this week's lectures).

### Explore data labels
Run the next two code cells to create a list of the names of each patient condition or disease.
"""

columns = train_df.keys()
columns = list(columns)
print(columns)

# Remove unnecesary elements
columns.remove('Image')
columns.remove('PatientId')
# Get the total classes
print(f"There are {len(columns)} columns of labels for these conditions: {columns}")

"""Run the next cell to print out the number of positive labels (1's) for each condition"""

# Print out the number of positive labels for each class
for column in columns:
    print(f"The class {column} has {train_df[column].sum()} samples")

"""Have a look at the counts for the labels in each class above. Does this look like a balanced dataset?

### Data Visualization
Using the image names listed in the csv file, you can retrieve the image associated with each row of data in your dataframe.

Run the cell below to visualize a random selection of images from the dataset.
"""

# Extract numpy values from Image column in data frame
images = train_df['Image'].values

# Extract 9 random images from it
# Sabit random sonuçlar için seed değeri
np.random.seed(53)

# 9 rastgele görsel seçimi
random_images = [np.random.choice(images) for i in range(9)]
#random_images = [np.random.choice(images) for i in range(9)]

# Extract 9 random images from it
random_images = [np.random.choice(images) for i in range(9)]

# Location of the image dir
img_dir = 'nih/images_small/'

print('Display Random Images')

# Adjust the size of your images
plt.figure(figsize=(20,10))

# Iterate and plot random images
for i in range(9):
    plt.subplot(3, 3, i + 1)
    img = plt.imread(os.path.join(img_dir, random_images[i]))
    plt.imshow(img, cmap='gray')
    plt.axis('off')

# Adjust subplot parameters to give specified padding
plt.tight_layout()

"""** RASTGELE SECİLMİŞ 9 GÖRÜNTÜNÜN ISTATISTIKSEL ÖZELLİKLERİNİ (MAKSIMUM, MINIMUM, MEAN VE STD) HESAPLAYIN. ORNEK OLARAK BIR GORUNTU ICIN HESAPLAMA YAPILMISTIR"""

import matplotlib.pyplot as plt
import os
import numpy as np

# 3x3 grid'de 9 görüntüyü gösterme ve her birinin istatistiklerini hesaplama
fig, axes = plt.subplots(3, 3, figsize=(15, 15))

for i, img_name in enumerate(random_images):
    # Görüntüyü yükle
    img_path = os.path.join(img_dir, img_name)
    image = plt.imread(img_path)

    # Görüntü özelliklerini hesapla
    max_val = image.max()
    min_val = image.min()
    mean_val = image.mean()
    std_val = image.std()

    # Görüntüyü, colorbar ve beyaz çizgilerle ızgara ile birlikte göster
    ax = axes[i // 3, i % 3]
    img_plot = ax.imshow(image, cmap='gray')
    fig.colorbar(img_plot, ax=ax, fraction=0.046, pad=0.04)

    # Beyaz çizgilerle ızgara ekle
    ax.set_xticks(np.arange(0, image.shape[1], step=100))
    ax.set_yticks(np.arange(0, image.shape[0], step=100))
    ax.grid(which='both', color='white', linestyle='-', linewidth=0.5)

    # İstatistiksel bilgileri başlık olarak ekle
    ax.set_title(f'Image {i+1}\nMax: {max_val:.4f}, Min: {min_val:.4f}, Mean: {mean_val:.4f}, Std Dev: {std_val:.4f}', fontsize=10)
    ax.axis('off')

plt.tight_layout()
plt.show()

"""Yukarıdaki görsellerin istatistiksel analizine göre, maksimum değerler genellikle 1'e çok yakın veya tam 1 olduğundan, X-ray görüntülerinin yoğun kontrast içerdiği ve belirgin parlak alanların bulunduğu görülmektedir. Ortalama değerler, her bir görüntünün genel parlaklık seviyesini yansıtırken, standart sapma değerleri parlaklık dağılımındaki değişkenliği ifade etmektedir. Örneğin, Image 1'de düşük standart sapma, parlaklık dağılımının daha homojen olduğunu ve kontrastın sınırlı olduğunu gösterirken, Image 2'de yüksek ortalama ve standart sapma, daha belirgin parlak noktaların ve yüksek kontrastın varlığını işaret etmektedir. Bunun yanında, Image 3 gibi düşük ortalama ve düşük standart sapma değerlerine sahip görüntülerde genel parlaklık seviyesi düşük ve kontrast dar bir aralıktadır. Öte yandan, Image 5 ve Image 7 gibi standart sapma değerlerinin nispeten yüksek olduğu görseller, bazı bölgelerde aşırı parlaklık veya karanlık alanlar içeriyor olabilir. Genel olarak, ortalama değerin yüksek olduğu (örneğin, Image 6 ve Image 9) görseller, daha parlak bir yapı sergilerken, düşük standart sapmalı görüntüler homojen bir parlaklık dağılımına sahiptir. Bu analiz, her bir görüntünün parlaklık ve kontrast özelliklerini daha iyi anlamamıza olanak sağlamaktadır.

RASTGELE SECILMIS 9 GORUNTUNUN HISTOGRAMINI CIZDIRIN. ORNEK OLARAK BIR GORUNTU ICIN VERILMISTIR.
"""

plt.figure(figsize=(20, 20))

# 9 resim için histogram oluşturma
for i in range(9):
    img_path = os.path.join(img_dir, random_images[i])
    raw_image = plt.imread(img_path)

    plt.subplot(3, 3, i + 1)
    sns.histplot(raw_image.ravel(), bins=256, color='gray', kde=False,
                 label=f'Pixel Mean: {np.mean(raw_image):.2f}, Std Dev: {np.std(raw_image):.2f}')

    plt.legend(loc='upper right', fontsize=10)
    plt.title(f'Image {i+1} Pixel Intensity Distribution')
    plt.xlabel('Pixel Intensity')
    plt.ylabel('Frequency')

plt.tight_layout()
plt.show()

"""Görseldeki histogramlar, dokuz farklı görüntünün piksel yoğunluğu dağılımını göstermektedir. Dokuz görselin piksel yoğunluğu analizine göre her birinin farklı parlaklık ve kontrast özelliklerine sahip olduğu görülmektedir. İlk görsel, düşük kontrastlı bir yapıya sahip olup karanlık alanların daha yoğun olduğunu göstermektedir. İkinci görsel ise geniş bir dağılıma sahiptir ve parlak alanların ağırlıkta olduğu dengeli bir yapı sergilemektedir. Üçüncü görsel, karanlık tonların baskın olduğu, düşük kontrastlı bir dağılıma işaret etmektedir. Dördüncü görselde hem karanlık hem de parlak alanlar dengeli şekilde yer almakta, bu da zengin bir kontrast sunmaktadır. Beşinci görselde karanlık tonlar ağırlıkta olup daha düşük parlaklık seviyeleri dikkat çekmektedir. Altıncı görsel, parlak alanların baskın olduğu ve daha dar bir aralıkta yoğunlaştığı bir yapıya sahiptir. Yedinci görsel, karanlık bölgelerin ağırlıkta olduğu ancak geniş bir piksel yoğunluğu aralığı sunduğu için yüksek kontrastlı bir yapıya işaret etmektedir. Sekizinci görsel, orta parlaklık seviyelerinde yoğunlaşmış ve homojen bir yapıya sahip olup nötr kontrast özellikleri taşımaktadır. Son olarak dokuzuncu görselde parlak alanlar baskın bir şekilde öne çıkmakta ve açık renk tonlarının görüntüde ağır bastığı anlaşılmaktadır.

GORUNTULERE CONTRAST STRECTCHING YAPINIZ, CONTRAST STRECTCHING GORUNTULERINE GAMMA TRANSFORMATIONU UYGULAYINIZ. ORNEK OLARAK BIR GORUNTU ICIN VERILMISTIR
"""

pip install numpy

import numpy as np
import matplotlib.pyplot as plt
from skimage import exposure
import os # Import the os module
# Örnek olarak random_images isimli 9 görüntü olduğunu varsayıyoruz
# random_images listesi içerisindeki her bir raw_image üzerinde işlem yapılacak
img_dir = 'nih/images_small/'


for i, image_file  in enumerate(random_images, start=1):
    # Her görüntü için min ve max değeri hesapla
    raw_image = plt.imread(os.path.join(img_dir, image_file))
    min_val, max_val = raw_image.min(), raw_image.max()

    # Adım 1: Kontrast genişletme (normalize edip [0, 255] aralığına çekiyoruz)
    contrast_stretched = (raw_image - min_val) / (max_val - min_val)  # Normalize [0, 1]
    contrast_stretched = (contrast_stretched * 255).astype(np.uint8)  # [0, 255] aralığına ölçeklendir

    # Adım 2: Kontrast eşitleme (histogram eşitleme)
    equalized_image = exposure.equalize_hist(contrast_stretched)  # [0, 1] aralığında değer döndürür
    equalized_image = (equalized_image * 255).astype(np.uint8)  # [0, 255] aralığına ölçeklendir

    # Adım 3: Gamma düzeltmesi
    gamma = 1.2  # Gamma değeri
    gamma_corrected = np.power(equalized_image / 255.0, gamma) * 255
    gamma_corrected = gamma_corrected.astype(np.uint8)

    # Görüntüleri ve histogramları çizdirme
    plt.figure(figsize=(18, 10))
    plt.suptitle(f"Image {i} Processing", fontsize=16)

    # Orijinal görüntü ve histogram
    plt.subplot(2, 4, 1)
    plt.imshow(raw_image, cmap='gray')
    plt.title('Original Image')
    plt.colorbar()
    plt.subplot(2, 4, 5)
    plt.hist(raw_image.ravel(), bins=256, color='gray')
    plt.title("Original Image Histogram")

    # Kontrast genişletilmiş görüntü ve histogram
    plt.subplot(2, 4, 2)
    plt.imshow(contrast_stretched, cmap='gray')
    plt.title('Contrast-Stretched Image')
    plt.colorbar()
    plt.subplot(2, 4, 6)
    plt.hist(contrast_stretched.ravel(), bins=256, color='gray')
    plt.title("Contrast-Stretched Histogram")

    # Histogram eşitlenmiş görüntü ve histogram
    plt.subplot(2, 4, 3)
    plt.imshow(equalized_image, cmap='gray')
    plt.title('Contrast Equalized Image')
    plt.colorbar()
    plt.subplot(2, 4, 7)
    plt.hist(equalized_image.ravel(), bins=256, color='gray')
    plt.title("Equalized Histogram")

    # Gamma düzeltmeli görüntü ve histogram
    plt.subplot(2, 4, 4)
    plt.imshow(gamma_corrected, cmap='gray')
    plt.title(f'Gamma-Corrected Image (Gamma={gamma})')
    plt.colorbar()
    plt.subplot(2, 4, 8)
    plt.hist(gamma_corrected.ravel(), bins=256, color='gray')
    plt.title("Gamma-Corrected Histogram")

    plt.tight_layout()
    plt.show()

"""# Görüntü 1
Original Image: Düşük kontrastlı, gri tonlar dar bir aralıkta yoğunlaşmış. Detaylar yeterince belirgin değil.

Contrast- Stretched Image Gri tonlar genişlemiş, karanlık ve parlak alanlar daha net ayrılmış. Kemik ve yumuşak dokular daha belirgin.

Equalized Image: Görüntüdeki aydınlık ve karanlık alanlar dengelenmiş, daha geniş bir kontrast aralığı sağlanmış.

Gamma-Corrected Image: Görüntü daha parlak, düşük tonlardaki ayrıntılar vurgulanmış.
# Görüntü 2
Original Image: Karanlık bölgeler daha baskın, parlak bölgeler sınırlı.

Contrast- Stretched Image: Düşük kontrast düzeltilmiş, kemik yapısındaki detaylar daha net hale gelmiş.

Equalized Image: Genel parlaklık artmış, karanlık bölgelerde detaylar daha belirgin.

Gamma-Corrected Image: Görüntüde parlaklık artışı dikkat çekiyor, özellikle düşük ışık detayları vurgulanmış.
# Görüntü 3
Original Image: Görüntü düşük kontrastlı ve karanlık. Yapılar zayıf şekilde algılanıyor.

Contrast- Stretched Image: Görüntüye keskinlik eklenmiş, yumuşak dokular daha net.

Equalized Image: Parlaklık ve karanlık alanlarda denge sağlanmış, genel kontrast artırılmış.

Gamma-Corrected Image: Görüntü parlak tonlarda yoğunlaşmış, dokular daha dikkat çekici hale gelmiş.

# Görüntü 4
Original Image: Görüntü düşük kontrastlı, histograma bakıldığında gri tonlar dar bir aralıkta.

Contrast- Stretched Image: Yapısal detaylar güçlenmiş, gri tonlar arasında geçiş daha iyi.

Equalized Image: Tüm gri tonları dengeli şekilde dağılmış, kontrast en üst düzeye çıkmış.

Gamma-Corrected Image: Görüntü parlak tonlara kaymış, düşük parlaklık seviyelerindeki detaylar artırılmış.
# Görüntü 5
Original Image: Kontrast düşük, detayların ayırt edilmesi zor.

Contrast- Stretched Image: Görüntüdeki nesneler ve dokular daha keskin ve belirgin.

Equalized Image: Görüntünün tüm ton aralığında denge sağlanmış, parlak ve karanlık alanlar arasındaki geçiş iyileşmiş.

Gamma-Corrected Image: Görüntü daha parlak, düşük aydınlık detayları belirginleşmiş.
# Görüntü 6
Original Image: Görüntü düşük dinamik aralıkta. Detaylar yeterince belirgin değil.

Contrast- Stretched Image: Gri tonlar genişletilmiş, daha fazla detay açığa çıkarılmış.

Equalized Image: Görüntü dengeli bir parlaklık sunuyor, gri tonlar eşitlenmiş.

Gamma-Corrected Image: Parlaklıkta artış, düşük tonlarda daha fazla ayrıntı.
# Görüntü 7
Original Image: Görüntüde düşük kontrast hakim, dokular yeterince net değil.

Contrast- Stretched Image: Görüntüye netlik kazandırılmış, özellikle iç yapılar belirginleşmiş.

Equalized Image: Görüntüdeki gri tonlar dengelenmiş, detaylar daha belirgin hale gelmiş.

Gamma-Corrected Image: Görüntüde genel parlaklık artışı sağlanmış, düşük ışıklı bölgeler daha belirgin.
# Görüntü 8
Original Image: Görüntüde kontrast eksikliği dikkat çekiyor, histogram dar bir aralıkta yoğunlaşmış.

Contrast- Stretched Image: Görüntü daha net, karanlık ve parlak alanlar ayrılmış.

Equalized Image: Daha dengeli bir görüntü, gri tonlar tüm aralığa yayılmış.

Gamma-Corrected Image: Görüntü genel olarak daha parlak, düşük parlaklık seviyesindeki detaylar güçlendirilmiş.
# Görüntü 9
Original Image: Düşük kontrast ve dar bir histogram aralığı.

Contrast- Stretched Image: Görüntüde detaylar belirgin hale gelmiş, kemik yapısı daha net.

Equalized Image: Kontrast maksimum seviyeye çıkarılmış, tonlar daha eşit şekilde dağılmış.

Gamma-Corrected Image: Görüntü daha parlak, düşük ışık detayları vurgulanmış.


"""

import matplotlib.pyplot as plt
from skimage import exposure
import os # Import the os module
# Örnek olarak random_images isimli 9 görüntü olduğunu varsayıyoruz
# random_images listesi içerisindeki her bir raw_image üzerinde işlem yapılacak
img_dir = 'nih/images_small/'


for i, image_file  in enumerate(random_images, start=1):
    # Her görüntü için min ve max değeri hesapla
    raw_image = plt.imread(os.path.join(img_dir, image_file))
    min_val, max_val = raw_image.min(), raw_image.max()

    # Adım 1: Kontrast genişletme (normalize edip [0, 255] aralığına çekiyoruz)
    contrast_stretched = (raw_image - min_val) / (max_val - min_val)  # Normalize [0, 1]
    contrast_stretched = (contrast_stretched * 255).astype(np.uint8)  # [0, 255] aralığına ölçeklendir

    # Adım 2: Kontrast eşitleme (histogram eşitleme)
    equalized_image = exposure.equalize_hist(contrast_stretched)  # [0, 1] aralığında değer döndürür
    equalized_image = (equalized_image * 255).astype(np.uint8)  # [0, 255] aralığına ölçeklendir

    # Adım 3: Gamma düzeltmesi
    gamma = 1.4  # Gamma değeri
    gamma_corrected = np.power(equalized_image / 255.0, gamma) * 255
    gamma_corrected = gamma_corrected.astype(np.uint8)

    # Görüntüleri ve histogramları çizdirme
    plt.figure(figsize=(18, 10))
    plt.suptitle(f"Image {i} Processing", fontsize=16)

    # Orijinal görüntü ve histogram
    plt.subplot(2, 4, 1)
    plt.imshow(raw_image, cmap='gray')
    plt.title('Original Image')
    plt.colorbar()
    plt.subplot(2, 4, 5)
    plt.hist(raw_image.ravel(), bins=256, color='gray')
    plt.title("Original Image Histogram")

    # Kontrast genişletilmiş görüntü ve histogram
    plt.subplot(2, 4, 2)
    plt.imshow(contrast_stretched, cmap='gray')
    plt.title('Contrast-Stretched Image')
    plt.colorbar()
    plt.subplot(2, 4, 6)
    plt.hist(contrast_stretched.ravel(), bins=256, color='gray')
    plt.title("Contrast-Stretched Histogram")

    # Histogram eşitlenmiş görüntü ve histogram
    plt.subplot(2, 4, 3)
    plt.imshow(equalized_image, cmap='gray')
    plt.title('Contrast Equalized Image')
    plt.colorbar()
    plt.subplot(2, 4, 7)
    plt.hist(equalized_image.ravel(), bins=256, color='gray')
    plt.title("Equalized Histogram")

    # Gamma düzeltmeli görüntü ve histogram
    plt.subplot(2, 4, 4)
    plt.imshow(gamma_corrected, cmap='gray')
    plt.title(f'Gamma-Corrected Image (Gamma={gamma})')
    plt.colorbar()
    plt.subplot(2, 4, 8)
    plt.hist(gamma_corrected.ravel(), bins=256, color='gray')
    plt.title("Gamma-Corrected Histogram")

    plt.tight_layout()
    plt.show()

"""# Görüntü 1:

Orijinal görüntüye karşıtlık artırma uygulanarak dinamik aralık genişletilmiş ve kontrast artırılmış. Bu sayede görüntüdeki ayrıntılar ve tonlamalar daha belirgin hale gelmiş.
Daha sonra histogram eşitleme işlemiyle parlaklık ve kontrast dağılımı iyileştirilmiş. Böylece görüntü daha dengeli bir ton haritasına sahip olmuş.
Son olarak gamma düzeltme ile parlaklık ve ton dengeleri ayarlanmış. Bu, görüntünün genel görsel kalitesini artırmış.

# Görüntü 2:

Orijinal görüntü de benzer şekilde karşıtlık artırma, histogram eşitleme ve gamma düzeltme işlemlerine tabi tutulmuş. Sonuçta kontrast, parlaklık ve ton haritası iyileştirilmiş.

# Görüntü 3:

Bu görüntü üzerinde de aynı görüntü işleme adımları (karşıtlık artırma, histogram eşitleme, gamma düzeltme) uygulanmış. Böylece görüntünün görsel kalitesi ve anlaşılırlığı geliştirilmiş.

# Görüntü 4:

Orijinal görüntüye karşıtlık artırma ve histogram eşitleme işlemleri uygulanmış.
Daha sonra gamma düzeltme ile parlaklık ve ton haritası ayarlanmış.
Sonuçta, görüntünün kontrast, parlaklık ve ton dengesi optimize edilmiş.

# Görüntü 5:

Orijinal görüntüye karşıtlık artırma uygulanarak ayrıntılar ve tonlamalar iyileştirilmiş.
Histogram eşitleme ile parlaklık ve kontrast dağılımı optimize edilmiş.
Gamma düzeltme ile genel parlaklık ve ton dengesi ayarlanmış.

# Görüntü 6:

Orijinal görüntüye de benzer işlemler (karşıtlık artırma, histogram eşitleme, gamma düzeltme) uygulanmış.
Sonuçta görüntünün görsel kalitesi ve ayrıntı seviyesi artmış.

# Görüntü 7:

Orijinal görüntü üzerinde yine karşıtlık artırma, histogram eşitleme ve gamma düzeltme teknikleri kullanılmış.
Bu işlemler görüntünün görünümünü ve anlaşılırlığını önemli derecede iyileştirmiş.

# Görüntü 8:

Burada da aynı görüntü işleme adımları (karşıtlık artırma, histogram eşitleme, gamma düzeltme) uygulanmış.
Sonuçta görüntünün kalitesi ve ayrıntı seviyesi yükseltilmiş.

# Görüntü 9:

Orijinal görüntüye karşıtlık artırma ve histogram eşitleme işlemleri gerçekleştirilmiş.
Daha sonra gamma düzeltme ile parlaklık ve ton dengesi ayarlanmış.
Böylece görüntü daha net ve görsel olarak daha kaliteli hale gelmiş.

Sonuçlar, görüntülerin görsel kalitesini, ayrıntı seviyesini ve anlaşılırlığını önemli ölçüde artırmıştır.
"""

# Plot histograms of pixel intensity distributions for each gamma-corrected image
plt.figure(figsize=(20, 20))

for i, image_file in enumerate(random_images, start=1):
    img_path = os.path.join(img_dir, image_file)
    raw_image = plt.imread(img_path)

    # Pre-process the image and apply gamma correction
    min_val, max_val = raw_image.min(), raw_image.max()
    contrast_stretched = (raw_image - min_val) / (max_val - min_val) * 255
    contrast_stretched = contrast_stretched.astype(np.uint8)
    equalized_image = exposure.equalize_hist(contrast_stretched) * 255
    gamma_corrected = np.power(equalized_image / 255.0, 1.4) * 255
    gamma_corrected = gamma_corrected.astype(np.uint8)

    # Plot histogram for each gamma-corrected image
    plt.subplot(3, 3, i)
    sns.histplot(gamma_corrected.ravel(), bins=256, color='gray', kde=False,
                 label=f'Mean: {np.mean(gamma_corrected):.4f}, Std Dev: {np.std(gamma_corrected):.4f}')

    plt.legend(loc='upper right', fontsize=10)
    plt.title(f'Gamma-Corrected Image {i} Pixel Intensity Distribution')
    plt.xlabel('Pixel Intensity')
    plt.ylabel('Frequency')

plt.tight_layout()
plt.show()

"""# 1. Görüntü 1
Dağılım: Piksel yoğunlukları geniş bir aralığa yayılmış ancak düşük yoğunluklu piksellerde belirgin bir tepe noktası var.

Ortalama (Mean): 106.6359

Standart Sapma (Std Dev): 76.5437 (geniş bir yoğunluk aralığını ifade eder).

Yorum: Görüntü orta parlaklık seviyesindedir. Düşük yoğunluklu piksellerde birikim, görüntünün koyu alanlara sahip olduğunu gösterir. Ancak daha açık tonlara da yer verilmiş.
# 2. Görüntü 2
Dağılım: Yoğunluklar 0-255 aralığında yayılmış, fakat histogram biraz daha düzgün ve yumuşak geçişlere sahip.

Ortalama (Mean): 106.4952

Standart Sapma (Std Dev): 76.7392

Yorum: Orta düzey bir parlaklık seviyesini işaret eder. Düşük ve orta yoğunluklu pikseller baskın. Görüntüde belirgin kontrast farkları olmayabilir.
# 3. Görüntü 3
Dağılım: İki zirve (bimodal dağılım) dikkat çekiyor. Düşük ve yüksek yoğunluklarda yığılma mevcut.

Ortalama (Mean): 106.7028

Standart Sapma (Std Dev): 76.4837

Yorum: Görüntüde hem koyu hem de açık alanlar belirgin. Bu, yüksek kontrastlı bir görüntüye işaret edebilir. Özellikle nesne-arka plan ayrımı gibi durumlarda bu tür dağılımlar sık görülür.
# 4. Görüntü 4
Dağılım: Düşük piksel yoğunluklarında ciddi bir yoğunlaşma var. Yüksek yoğunluklarda neredeyse hiç piksel yok.

Ortalama (Mean): 106.8017

Standart Sapma (Std Dev): 75.8445

Yorum: Görüntü karanlık alanların baskın olduğu bir yapıya sahip. Parlaklık düşük, kontrast seviyesi de görece sınırlı olabilir.
# 5. Görüntü 5
Dağılım: Hem düşük hem de orta seviyelerde bazı yığılmalar mevcut. Yoğunluk dağılımı genel olarak dengeli.

Ortalama (Mean): 106.7985

Standart Sapma (Std Dev): 76.6628

Yorum: Orta parlaklıkta bir görüntü. Çok karanlık ya da aşırı parlak alanlar bulunmuyor gibi görünüyor.
# 6. Görüntü 6
Dağılım: Yüksek yoğunluklu piksellerin hakimiyeti dikkat çekiyor. Özellikle 200 civarında yoğunlaşma var.

Ortalama (Mean): 106.7438

Standart Sapma (Std Dev): 76.5443

Yorum: Görüntü parlak alanların baskın olduğu bir yapıya sahip olabilir. Açık tonlar ağırlıkta, bu da görüntünün parlak nesneler içerdiğini düşündürür.
# 7. Görüntü 7
Dağılım: Düşük yoğunluklarda ciddi bir birikim var. Orta ve yüksek yoğunluklar çok sınırlı.

Ortalama (Mean): 106.7054

Standart Sapma (Std Dev): 75.9850

Yorum: Görüntü ağırlıklı olarak karanlık tonlardan oluşuyor. Bu durum, düşük ışıklı bir ortamda çekilmiş görüntüler için tipiktir.
# 8. Görüntü 8
Dağılım: Daha homojen bir dağılım dikkat çekiyor. Tüm yoğunluklar neredeyse eşit şekilde temsil edilmiş.

Ortalama (Mean): 106.5256

Standart Sapma (Std Dev): 76.3747

Yorum: Görüntü, dengeli bir parlaklığa ve kontrast seviyesine sahip gibi görünüyor. Açık ve koyu alanlar eşit şekilde yayılmış olabilir.
# 9. Görüntü 9
Dağılım: Çift zirve (bimodal) dikkat çekiyor. Düşük yoğunluklarda bir tepe noktası, ardından yüksek yoğunluklara doğru bir başka tepe noktası var.

Ortalama (Mean): 106.8456

Standart Sapma (Std Dev): 76.7158

Yorum: Bu dağılım, sahnede açık ve koyu bölgeler arasında bir ayrım olduğunu gösterebilir. Görüntünün yüksek kontrast içerdiği düşünülüyor.





Tüm görüntülerde ortalama piksel yoğunluğu 106 civarında, bu da genel olarak orta parlaklık seviyesinde olduklarını gösteriyor. Ancak bazı histogramlar (özellikle 4, 7) daha düşük parlaklık seviyesine sahipken, diğerleri (özellikle 6) daha yüksek parlaklık alanlarını temsil ediyor. Standart sapmaların 75-76 civarında olması, yoğunluk dağılımlarının geniş bir aralığa yayıldığını ve görüntülerin farklı kontrast seviyelerine sahip olduğunu gösteriyor.

Eğer bu görüntüler belirli bir uygulama için (örneğin, görüntü işleme veya model eğitiminde) analiz ediliyorsa, histogram eşitleme veya başka parlaklık-contrast iyileştirme yöntemleri düşünülebilir. Ayrıca, bu dağılımların görüntülerin bağlamına göre değerlendirilmesi önemlidir.

TUM GORUNTULERE MEDIAN VE GAUSSIAN BLUR UYGULAYIN
"""

import cv2

plt.figure(figsize=(12, 48))

for i, image_file in enumerate(random_images, start=1):

    img_path = os.path.join(img_dir, image_file)
    raw_image = plt.imread(img_path)


    min_val, max_val = raw_image.min(), raw_image.max()
    contrast_stretched = (raw_image - min_val) / (max_val - min_val) * 255
    contrast_stretched = contrast_stretched.astype(np.uint8)
    equalized_image = exposure.equalize_hist(contrast_stretched) * 255
    gamma_corrected = np.power(equalized_image / 255.0, 1.4) * 255
    gamma_corrected = gamma_corrected.astype(np.uint8)


    median_filtered = cv2.medianBlur(gamma_corrected, 5)


    gaussian_filtered = cv2.GaussianBlur(gamma_corrected, (5, 5), 0)


    plt.subplot(9, 2, 2*i - 1)
    plt.imshow(median_filtered, cmap='gray')
    plt.title(f"Image {i} - Median Filtered Image")

    plt.subplot(9, 2, 2*i)
    plt.imshow(gaussian_filtered, cmap='gray')
    plt.title(f"Image {i} - Gaussian Filtered Image")

plt.tight_layout()
plt.show()

"""# 1. Görüntü Çifti (Image 1 - Median & Gaussian)

Median: Göğüs röntgeninin detayları korunmuş. Gürültüler giderilmiş.

Gaussian: Detaylarda hafif kayıplar görülüyor. Görüntü daha yumuşak bir yapıya sahip.
# 2. Görüntü Çifti (Image 2 - Median & Gaussian)

Median: Netlik korunmuş, kenarlar keskin.

Gaussian: Yumuşama artmış ve kenarlardaki belirginlik azalmış.
# 3. Görüntü Çifti (Image 3 - Median & Gaussian)

Median: Görüntü daha temiz ve ayrıntılar korunmuş.

Gaussian: Görüntü daha bulanık ve pürüzsüz.
# 4. Görüntü Çifti (Image 4 - Median & Gaussian)

Median: Göğüs kafesi detayları korunarak gürültü temizlenmiş.

Gaussian: Detaylar bulanıklaşmış, pürüzsüzlük artmış.
# 5. Görüntü Çifti (Image 5 - Median & Gaussian)

Median: Kenarlar korunmuş, görüntü net.

Gaussian: Detaylar yumuşamış, genel bir bulanıklık hakim.
# 6. Görüntü Çifti (Image 6 - Median & Gaussian)

Median: Küçük gürültüler giderilmiş, detaylı görünüm korunmuş.

Gaussian: Görüntü daha estetik bir bulanıklığa sahip, ama netlik düşmüş.
# 7. Görüntü Çifti (Image 7 - Median & Gaussian)

Median: İskelet detayları ve yapı net şekilde görünüyor.

Gaussian: Detaylar azalmış, bulanıklık belirgin.
# 8. Görüntü Çifti (Image 8 - Median & Gaussian)

Median: Gürültü temizlenmiş, kenarlar net.

Gaussian: Görüntüde daha fazla yumuşama var.
# 9. Görüntü Çifti (Image 9 - Median & Gaussian)

Median: Keskinlik korunmuş, küçük gürültüler temizlenmiş.

Gaussian: Görüntü genel olarak bulanık ve yumuşak görünüyor.

# Genel Sonuç:
Median Filter: Detay koruma ve gürültü temizleme için uygun. Tıbbi görüntülerde tanı için detay kaybını önlemek adına daha çok tercih edilir.

Gaussian Filter: Görüntü yumuşatma ve estetik bir görünüm sağlamak için kullanışlıdır ancak tıbbi analiz için dikkat edilmesi gerekir.

DERECESI RASTGELE 0 ILA 10 ARASINDA OLACAK SEKILDE ROTATION UYGULAYIN GORUNTUYE FLIPPING UYGULAYIN
"""

import cv2
import random
import matplotlib.pyplot as plt
import os


for i, image_file in enumerate(random_images, start=1):
    # Görüntüyü yükle
    img_path = os.path.join(img_dir, image_file)
    raw_image = plt.imread(img_path)

    # Median filtre uygulaması
    median_filtered = cv2.medianBlur(raw_image, 5)

    # 0 ile 10 arasında rastgele bir dönüş açısı seçme
    angle = random.uniform(0, 10)
    center = (median_filtered.shape[1] // 2, median_filtered.shape[0] // 2)
    rotation_matrix = cv2.getRotationMatrix2D(center, angle=10, scale=1.0)
    rotated_image = cv2.warpAffine(median_filtered, rotation_matrix, (median_filtered.shape[1], median_filtered.shape[0]))

    # Yatay flip (çevirme) uygulama
    flipped_horizontal = cv2.flip(median_filtered, 1)

    # Görüntüleri yan yana gösterme
    plt.figure(figsize=(12, 60))  # Daha büyük bir boyutta çizim için
    plt.subplot(9, 2, 2*i - 1), plt.imshow(rotated_image, cmap='gray'), plt.title(f"Image {i} -Rotated Image")
    plt.imshow(rotated_image, cmap='gray')

    plt.subplot(9, 2, 2*i)
    plt.imshow(flipped_horizontal, cmap='gray'), plt.imshow(flipped_horizontal, cmap='gray'), plt.title(f"Image {i} -Horizontally Flipped Image")
    plt.show()

# Görüntülerin arasındaki boşluğu azaltma
plt.subplots_adjust(wspace=0.1, hspace=0.3)
plt.show()

"""# 1. Görüntü Çifti (Image 1 - Rotated & Horizontally Flipped)
Rotated Image: Görüntü hafifçe saat yönünde döndürülmüş. Kenarlarda siyah boşluklar oluşmuş, bu da görüntü hizalamasında değişiklik meydana getirmiş.

Horizontally Flipped Image: Görüntü yatay olarak çevrildiği için sağ-sol yer değiştirmiş (örneğin, "R" etiketi sol tarafa geçmiş). Bu dönüşüm, simetrik analizlerde önemli olabilir.
# 2. Görüntü Çifti (Image 2 - Rotated & Horizontally Flipped)
Rotated Image: Görüntü yine rastgele bir açıda döndürülmüş. Göğüs yapısında bozulma olmamakla birlikte çerçeve pozisyonunda farklılık oluşmuş.

Horizontally Flipped Image: Göğüs kafesinin sağ ve sol tarafları yer değiştirmiş. Yatay çevirme, bazı algoritmalarda çeşitliliği artırmak için kullanılır.
# 3. Görüntü Çifti (Image 3 - Rotated & Horizontally Flipped)
Rotated Image: Görüntü, açısal olarak farklı bir perspektife getirilmiş. Bu tür dönüşümler, görüntü sınıflandırma algoritmalarını veri genişletme (data augmentation) amacıyla daha genel hale getirebilir.

Horizontally Flipped Image: Flipping işlemi yine sağ-sol yönlerini değiştirmiş. Bu değişiklik, simetriye dayalı patolojik analizlerde anlamlı olabilir.
# 4. Görüntü Çifti (Image 4 - Rotated & Horizontally Flipped)
Rotated Image: Hafifçe döndürülme uygulanmış ve bu, tıbbi görüntülerin açısal varyasyonlarına uyum sağlamak için önemli bir işlemdir. Ancak siyah kenar boşlukları, görsel bütünlükte kayıplara yol açabilir.

Horizontally Flipped Image: Görüntünün yatay çevrilmesiyle, özellikle röntgen etiketleri ve semboller ters çevrilmiş.
# 5. Görüntü Çifti (Image 5 - Rotated & Horizontally Flipped)
Rotated Image: Döndürme işlemi görüntüyü hafifçe eğmiş, ancak yapısal bilgide kayıp yok.

Horizontally Flipped Image: Görüntüdeki yön tersine çevrilmiş, bu da özellikle sol/sağ akciğer değerlendirmelerinde dikkat edilmesi gereken bir durum.

# 6. Görüntü Çifti (Image 6 - Rotated & Horizontally Flipped)
Rotated Image: Görüntü hafif bir açıyla döndürülmüş. Göğüs kafesindeki yapılar bozulmadan korunmuş, ancak siyah kenar boşlukları dikkat çekiyor. Görselin döndürülmesi, modelin çeşitli perspektiflerden öğrenmesini sağlar.

Horizontally Flipped Image: Görüntü yatay olarak çevrilmiş. Özellikle röntgen üzerindeki semboller (örneğin "R") tersine döndüğü için sağ-sol bilgisi dikkatle değerlendirilmeli.
# 7. Görüntü Çifti (Image 7 - Rotated & Horizontally Flipped)
Rotated Image: Görüntüye hafif bir saat yönünde döndürme uygulanmış. Bu dönüşüm, veri çeşitliliğini artırmak adına önemli bir teknik.

Horizontally Flipped Image: Yatay çevirme, sağ ve sol yönlerin yer değiştirmesine neden olmuş. Bu tür dönüşümler, görüntü sınıflandırma algoritmalarında yaygın olarak kullanılır ancak medikal bağlamda doğru tarafların belirtilmesi önemlidir.
# 8. Görüntü Çifti (Image 8 - Rotated & Horizontally Flipped)
Rotated Image: Görüntü, nispeten daha belirgin bir açıyla döndürülmüş. Özellikle görüntünün kenarlarındaki boşlukların artışı dikkat çekiyor. Bu tarz dönüşümler aşırı kullanılmamalıdır; aksi takdirde görsel bilgiler kaybolabilir.

Horizontally Flipped Image: Flipping sonrası, metinler ve semboller ters çevrilmiş. Bu durum, özellikle metin tabanlı tıbbi görüntülerde hata riskini artırabilir.
# 9. Görüntü Çifti (Image 9 - Rotated & Horizontally Flipped)
Rotated Image: Görüntü hafifçe döndürülerek perspektif çeşitliliği eklenmiş. Yapısal detaylar bozulmadan korunmuş, ancak bazı kenarlarda veri kaybı gözlenebilir.

Horizontally Flipped Image: Görüntünün sağ ve sol tarafları yer değiştirmiş. Akciğer yapısı ve göğüs kafesi analizlerinde sağ-sol ayrımı yapılması gereken durumlarda dikkat edilmelidir.

6.	Fourier Dönüşümü ve Filtreleme

o	Fourier dönüşümü ile görüntüyü frekans alanına çevirin, düşük frekansları geçiren bir maske uygulayın, ardından ters Fourier dönüşümü ile frekans alanında filtreleme yapın.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import os

plt.figure(figsize=(18, 36))  # 9 görsel için uygun boyut

for i, image_file in enumerate(random_images, start=1):
    # Görüntüyü yükle
    img_path = os.path.join(img_dir, image_file)
    raw_image = plt.imread(img_path)

    # Median filtre uygulaması
    median_filtered = cv2.medianBlur(raw_image, 5)

    # 0 ile 10 arasında rastgele bir dönüş açısı seçme
    angle = random.uniform(0, 10)
    center = (median_filtered.shape[1] // 2, median_filtered.shape[0] // 2)
    rotation_matrix = cv2.getRotationMatrix2D(center, angle=angle, scale=1.0)
    rotated_image = cv2.warpAffine(median_filtered, rotation_matrix, (median_filtered.shape[1], median_filtered.shape[0]))

    # Fourier dönüşümünü ve frekans alanı filtresini uygulama
    dft = cv2.dft(np.float32(rotated_image), flags=cv2.DFT_COMPLEX_OUTPUT)
    dft_shifted = np.fft.fftshift(dft)

    # Filtre maskesi oluşturma (orta düşük frekansları geçiren)
    rows, cols = rotated_image.shape
    crow, ccol = rows // 2, cols // 2
    mask = np.zeros((rows, cols, 2), np.uint8)
    mask[crow-30:crow+30, ccol-30:ccol+30] = 1  # Ortadaki düşük frekansları geçiren

    # Maskeyi uygula ve ters DFT al
    fshift = dft_shifted * mask
    f_ishift = np.fft.ifftshift(fshift)
    filtered_image = cv2.idft(f_ishift)
    filtered_image = cv2.magnitude(filtered_image[:, :, 0], filtered_image[:, :, 1])

    # Normalizasyon ve görselleştirme
    filtered_image = cv2.normalize(filtered_image, None, 0, 255, cv2.NORM_MINMAX)

    # Filtrelenmiş görüntüyü çizme
    plt.subplot(9, 2, 2*i - 1)
    plt.imshow(filtered_image, cmap='gray')
    plt.title(f"Image {i} - Frequency Domain Filtered", fontsize=12)
    plt.axis('off')

plt.tight_layout()
plt.show()

"""Görsel 1: Bu görüntüde genel detaylar korunmuş ancak ince yapılar hafif bulanık hale gelmiş. Bu durum düşük frekansların geçmesine izin veren maske kullanımını doğruluyor.

Görsel 2: İlk görüntüye kıyasla biraz daha fazla bulanıklık gözlemleniyor. Yüksek frekanslı bileşenler (örneğin, keskin kenarlar) daha fazla baskılanmış.

Görsel 3: Detayların biraz daha az belirgin olduğu görülüyor. Filtrenin kesme frekansı biraz daha düşük olabilir.

Görsel 4: Bu görüntüde ince detayların daha da kaybolduğu fark ediliyor. Daha geniş bir düşük frekans filtresi uygulanmış olabilir.

Görsel 5: Yapılar oldukça yumuşatılmış; neredeyse tüm ince detaylar yok olmuş. Bu, filtrenin yüksek frekansları ciddi şekilde bastırdığını gösteriyor.

Görsel 6: Görselde detaylar belirgin ölçüde kaybolmuş ancak genel yapılar hala seçilebiliyor. Daha yoğun bir düşük frekans geçiş filtresi etkisi mevcut.

Görsel 7: Filtrenin etkisi daha belirgin; neredeyse bulanık bir görüntü oluşmuş. Bu da çok dar bir yüksek frekans bandı bırakıldığını düşündürüyor.

Görsel 8: Görsel, çok yumuşak bir dokuya sahip. Detaylar tamamen kaybolmuş, düşük frekans bileşenler dışında neredeyse hiçbir şey kalmamış gibi.

Görsel 9: Diğerlerine kıyasla daha doğal bir görüntü sunuyor; düşük frekanslı filtre uygulansa da hala bazı orta frekanslar korunmuş olabilir.

7.Keskinleştirme ve Enterpolasyon

1.	Keskinleştirme
o	Unsharp masking tekniği kullanarak görüntüyü keskinleştirin.
2.	Bicubic Enterpolasyon
o	Keskinleştirilmiş görüntüyü iki kat büyüterek enterpolasyon uygulayın.
"""

import numpy as np
import cv2
import os
import matplotlib.pyplot as plt
from scipy.ndimage import zoom
from skimage import exposure

def process_images_and_sharpen(random_images, img_dir, gamma=1.2):
    for i, image_name in enumerate(random_images, start=1):
        # Görüntüyü yükle
        image_path = os.path.join(img_dir, image_name)
        raw_image = plt.imread(image_path)

        # Kontrast genişletme ve gamma düzeltmesi
        min_val, max_val = raw_image.min(), raw_image.max()
        contrast_stretched = (raw_image - min_val) / (max_val - min_val) * 255
        contrast_stretched = contrast_stretched.astype(np.uint8)

        equalized_image = exposure.equalize_hist(contrast_stretched) * 255
        equalized_image = equalized_image.astype(np.uint8)

        gamma_corrected = np.power(equalized_image / 255.0, gamma) * 255
        gamma_corrected = gamma_corrected.astype(np.uint8)

        # Keskinleştirme işlemi
        sharpening_kernel = np.array([[-1, -1, -1],
                                      [-1,  9, -1],
                                      [-1, -1, -1]])
        sharpened_image = np.clip(cv2.filter2D(gamma_corrected, -1, sharpening_kernel), 0, 255).astype(np.uint8)

        # Bicubic interpolasyon ile büyütme (2 kat)
        scale_factor = 2
        resized_image = zoom(sharpened_image, scale_factor, order=3)  # Bicubic interpolation with `order=3`

        # Görselleştirme: Keskinleştirilmiş ve büyütülmüş görüntüleri çizme
        plt.figure(figsize=(12, 6))
        plt.subplot(1, 2, 1), plt.imshow(sharpened_image, cmap='gray'), plt.title(f"Image {i} -Sharpened Image")
        plt.subplot(1, 2, 2), plt.imshow(resized_image, cmap='gray'), plt.title(f"Image {i} Interpolated (Upscaled)")

        plt.tight_layout()
        plt.show()

# Fonksiyonu çağır ve her görüntü için keskinleştirme ve enterpolasyon işlemlerini görselleştir
process_images_and_sharpen(random_images, img_dir)

"""# **1. Görsel**
Sharpened Image: Görüntünün detayları netleştirilmiş; özellikle kemik yapıları ve akciğer dokusu daha belirgin hale getirilmiş. Ancak unsharp masking, kontrast artırdığı için bazı bölgelerde hafif aşırı keskinleşme veya parlama görülebilir.

Interpolated (Upscaled) Image: Görüntü iki katına çıkarılmış ve detaylar korunmuş gibi görünüyor. Bicubic interpolasyon sayesinde kenar geçişlerinde pürüzsüzlük sağlanmış.
# 2. Görsel
Sharpened Image:  Detaylar başarılı şekilde öne çıkarılmış. Özellikle akciğerlerdeki doku sınırları ve radyografik işaretler daha net bir şekilde fark ediliyor. Ancak aşırı keskinleştirme izlenimi bazı bölgelerde ortaya çıkabilir.

Interpolated (Upscaled) Image:  Yüksek çözünürlükte detaylar korunmuş, ancak büyütme işlemi görüntünün doğal kontrastını hafif yumuşatmış gibi görünüyor. Bicubic interpolasyon kenarların yumuşak kalmasını sağlamış.
# 3. Görsel
Sharpened Image: Keskinleştirme, damarlar ve doku sınırlarını belirginleştirmiş. Görüntü genel olarak daha net, ancak bazı bölgelerde kontrast artışı belirgin şekilde fark ediliyor.

Interpolated (Upscaled) Image:  Detaylar başarılı bir şekilde büyütülmüş. Bicubic interpolasyon, büyütülen görüntüdeki geçişlerin yumuşak kalmasını sağlarken detay kaybını minimize etmiş.
# 4. Görsel
Sharpened Image: Akciğer dokusu ve kemik yapıları oldukça netleşmiş. Görüntü, orijinalinden daha belirgin kontrastlarla dikkat çekiyor. Bazı bölgelerde hafif yapaylık hissi oluşabilir.

Interpolated (Upscaled) Image:  İki kat büyütme işlemi sırasında detaylar korunmuş ve geçişler bicubic interpolasyon sayesinde düzgün kalmış. Orijinal keskinliğin bir kısmı korunmuş.

# 5. Görsel
Sharpened Image:  Akciğer dokusu ve çevresindeki kemik yapıları daha belirgin hale gelmiş. Özellikle omurga ve kaburga detayları net bir şekilde fark ediliyor. Ancak bazı parlak bölgelerde aşırı kontrast artışı gözlemlenebilir.

Interpolated (Upscaled) Image: Bicubic interpolasyon sayesinde detaylar korunmuş ve büyütme sırasında pikselleşme olmamış. Keskinleştirme etkisi büyütülen görüntüde de belirgin bir şekilde hissediliyor.
# 6. Görsel
Sharpened Image: Keskinleştirme, özellikle akciğerlerin alt kısımlarındaki detayları ve dokusal farklılıkları öne çıkarmış. Görüntünün genel netliği artmış ancak bazı bölgelerde kontrastın artışı, orijinal doku görünümünü bozabilir.

Interpolated (Upscaled) Image: Büyütme işlemi, keskinleştirme etkisini korurken detayların pürüzsüz bir şekilde genişletilmesini sağlamış. Bicubic interpolasyon, kenarların doğal kalmasını desteklemiş.
# 7. Görsel
Sharpened Image: Görüntüdeki damar ve doku detayları keskin bir şekilde ortaya çıkarılmış. Kaburga yapıları ve omurga net olarak görülebiliyor. Unsharp masking bazı bölgelerde görüntüyü biraz yapay hale getirmiş olabilir.

Interpolated (Upscaled) Image: İki kat büyütme sırasında görüntü pikselleşmeden genişletilmiş ve kenar geçişleri doğal görünümünü korumuş. Keskinleştirmenin etkisi büyütülen versiyonda da belirgin bir şekilde devam ediyor.
# 8. Görsel
Sharpened Image: Görüntüdeki tıbbi ekipmanlar ve dokusal sınırlar keskin bir şekilde öne çıkarılmış. Bununla birlikte, kontrast artışı nedeniyle parlak bölgelerde detay kaybı yaşanabilir.

Interpolated (Upscaled) Image: Bicubic interpolasyon, büyütme sırasında görüntüdeki pürüzsüzlüğü korumuş. Keskinleştirmenin olumlu etkileri büyütme sonrası da devam etmiş, ancak bazı bölgelerde aşırı parlama belirginleşmiş olabilir.
# 9. Görsel
Sharpened Image: Akciğer dokusu ve kaburgaların detayları çok net bir şekilde öne çıkmış. Görüntünün genel kontrastı artmış ve bu, detayların daha kolay fark edilmesini sağlamış.

Interpolated (Upscaled) Image:İki kat büyütme sonrası görüntüde detay kaybı yaşanmamış ve kenarlar düzgün bir şekilde genişletilmiş. Keskinleştirme etkisi büyütülen görüntüde de devam etmiş ve büyütme işlemi görüntü kalitesine olumlu katkı sağlamış.
"""